<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="Lambda Chess">
		<meta name="author" content="Mathieu Gauthron">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <section>
          <h1>JVM breakglass</h1>
          <h3>Using a Clojure REPL to troubleshoot live Java/JVM processes</h3>

          <!--<img  BORDER="0" src="img/LOWEMZONE.png" alt="lambda">-->
          <img BORDER="0" src="img/breakglass.jpeg" alt="chess">
          <!--<img width="320" height="299" BORDER="0" src="img/chess2.png" alt="chess">-->
          </p>
          Author:
          Mathieu Gauthron
          <aside class="notes">
          	(Ok, let's start)
            See this image?
			Who recognises it? (pause)
			Normally when you press on it it's because there is fire! (pause)
			Here it's the same but when you process is on fire. (pause)

			Today I'm here to demonstrate how Clojure and REPL can be introduced as a powerful troubleshooting tool within a pure Java or JVM based Application, without having to introduce any Clojure code within your project. (pause)

			My name is MG. (p) I worn many hats. (p) Currently I have the sexiest job in the world: DEvOPs in an Investment bank.

            (total time 20s)

          </aside>
        </section>

        <section id="Agenda">
          <h3>Agenda</h3>
            <ol>
              <li class="fragment">Traditional troubleshooting of a Java application</li>
              <li class="fragment">What is JVM-breakglass?</li>
              <li class="fragment">How to integrate it in an application?</li>
              <li class="fragment">Live Debugging demo</li>
            </ol>
          <aside class="notes">
          	During this presentation we will see how Java apps are troubleshooted traditionally.
          	What breakglass provides.
          	How easy it is to use this tool.
          	Finally we will run a live debugging demo.

          (time x: total time x mins)
          </aside>

        </section>

        <section id="troubleshoutingjava">

 

          <h3>Troubleshooting a Java application</h3>
 
            <ol>
              <li class="fragment">Debugger</li>
              <li class="fragment">Log/print statements</li>
              <li class="fragment">JMX</li>
              <li class="fragment">Adhoc interactive mechanism</li>
            </ol>

          <aside class="notes">
          How many people in the room use Java day to day?
          What do you normally do to track a bug? (pause)
Most of you must have used the debugger or print statements which are well established ways of tracking bugs in many languages (inc java).
The debugger is mostly useful when the bug can be reproduced on a development machine and can be narrowed down to a series or breakpoints. Debuggers have to stop the world which changes the nature of the problem your trying to study.
Log/print statements can be very powerful but  need to be planned before compilation, add clutter to the code and can slow down the application.
Same with JMX or interactive mechanism,very good to retreive or send selected information to your remote objects. Good to deal with a dynamic and complex problem. However needs a good deal of scaffolding and design needs to be applied to provide a powerful investigation tool.



          (time x : total time x mins)
          </aside>

        </section>
        <section>

 

          <h3>What can JVM-breakglass provide?</h3>
 
            <ol>
              <li class="fragment">Interactive prompt</li>
              <li class="fragment">See inside private members</li>
              <li class="fragment">Call arbitraty methods</li>
              <li class="fragment">Creation of new object instances</li>
              <li class="fragment">Monitor object state</li>
              <li class="fragment">Overwrite class definition on the fly</li>
              <li class="fragment">No need to use Clojure to develop the application</li>
            </ol>

          <aside class="notes">
In this crowd, we're probably all used to the fact that most function languages are equipped with a REPL which enable to poke around a live process to figure out what's going on?
Why can't we leverage this concept with any JVM application? (pause)
Java developers are used to the "write the code", compile, package and deploy cycle.
Why can't we prompt the process to display the content of an object, call methods, create objects at runtime without having to plan for it in advance?
With this tool you can do that and more... without having to specifically use Clojure in your project.          

          (time x : total time x mins)
          </aside>

        </section>

        <section data-markdown>
         <script type="text/template">
How to add JVM-breakglass to your project
-----------------------

Maven:        
```xml
<dependency>
  <groupId>net.matlux</groupId>
  <artifactId>jvm-breakglass</artifactId>
  <version>0.0.5</version>
</dependency>
```

Note:
To use JVM-breakglass, add the following dependency to your project.

         </script>
        </section>

        <section data-markdown>
        	<script type="text/template">
Inject the repl server
-----------------------
        
In Spring:        
```xml
<bean id="repl" class="net.matlux.NreplServerSpring">
  <constructor-arg index="0" value="1112" />
</bean>
```

Directly in Java:
```java
import net.matlux.NreplServer;
    new NreplServer(port) //start server listening onto port number
    .put("department",myObject);
```
Note:
Then in Spring add this bean. In case of a pure java application just call this constructor to start up the server.

			</script>
        </section>

        <section data-markdown>
        	<script type="text/template">
How to connect?
-----------------------
        
to get the console:        
```shell
lein repl :connect localhost:1112
```

Note:
Once the JVM-breakglass component is installed and running. You can use this lein command to remotely connect onto the server.

(time: 1min ; total 8 mins)
			</script>
        </section>

        <section>

          <img BORDER="0" src="img/demo.png" alt="demo">
          <aside class="notes">
          	A presentation wouldn't be complete without a demo.
          	To demonstrate the power of this tools, I thought it would be appropriate to use a web based Enterprise Application example written in Java/SpringMVC. Everyone knows that Enterprise applications are of a higher design quality but also notoriously difficult to work with. That's why I choose to use one of them for this demo.
          </aside>
        </section>

        <section>
          <h3>Let's take a step back</h3>
            <ol>
              <li class="fragment">Interactive prompt</li>
              <li class="fragment">Full JVM introspection</li>
              <li class="fragment">Access private/public members, methods, fields...</li>
              <li class="fragment">Call arbitrary methods</li>
              <li class="fragment">Monitor object state</li>
              <li class="fragment">Creation of new object instances</li>
              <li class="fragment">Overwrite class definition on the fly</li>
              <li class="fragment">No Clojure inside the Java project</li>
            </ol>
          <aside class="notes">

          (time x: total time x mins)
          </aside>
        </section>

        <section>
                  <img  width="420" height="400" border="0" src="img/question.png" alt="questions?">

                  <p>github: <a href="https://github.com/matlux/jvm-breakglass">https://github.com/matlux/jvm-breakglass</a>
                  <p>blog: <a href="http://www.matlux.net">http://www.matlux.net</a>
           <aside class="notes">
           
           Do you have any questions.

            (4-19 mins : total time 30 - 45 mins )

          </aside>
        </section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
