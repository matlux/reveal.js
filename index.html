<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="Lambda Chess">
		<meta name="author" content="Mathieu Gauthron">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <section>
          <h1>lambda.zone</h1>
          <h3>A platform for competing algorithms</h3>

          <!--<img  BORDER="0" src="img/LOWEMZONE.png" alt="lambda">-->
          <img width="320" height="299" BORDER="0" src="img/lambda2.png" alt="chess">
          <!--<img width="320" height="299" BORDER="0" src="img/chess2.png" alt="chess">-->
          </p>
          Author:
          Mathieu Gauthron
          <aside class="notes">
            Today I'm going to present a webplatform written entirely in Clojure that I have been working on for the past 5 months. I have called it lambda.zone.

            (total time 20s)

          </aside>
        </section>

        <section data-markdown>

What is it for?
-----------------

![d](img/board.png)

Note:
Its aim is to promote games like this one. Which I have called lambda chess.            

(time 10s : total time 30s)
        </section>

        <section>
        
          <h3>And...</h3>

          <img width="320" height="299" BORDER="0" src="img/330px-Go-board-animated.gif" alt="go">
          <aside class="notes">
            or this one. Lambda go.            
            (time 10s : total time 40s)
          </aside>

        </section>

        <section>
        
          <h3>and...</h3>

          <img width="320" height="299" BORDER="0" src="img/connect-four.jpg" alt="connect-four.jpg">
          <aside class="notes">
            or lambda connect-four.          
            (time 10s : total time 50s)
           </aside>

        </section>

        <section>
        
          <h3>And many more...</h3>
          <h3>But what do they have in common?</h3>
            <aside class="notes">
            and so on.
            (3 sec pause)... 
            Has anyone notice what they have in common?
            Yes! I would say they all are turn based adversarial games. (pause)
            This model is ideal because the decision of an oponent delegated throught the implementation of a strategy function.
            (time 40s : total time 1 min 30)
          </aside>
        </section>
        <section id="Agenda">

 

          <h3>Agenda</h3>
 
            <ol>
              <li class="fragment">What might an API look like?</li>
              <li class="fragment">How is the website designed?</li>
              <li class="fragment">Chess Engine Implementation</li>
            </ol>

          <aside class="notes">
          Now gone through a brief introduction of what the Platform main aim is, We're going to consider the following 3 main topics.
          Explore what a valid API to implement a strategy function might look like.;
          Go through the design choices for the platform.;
          Finally we will dive down and explore internals of the current Chess Engine implementation.

          (time 30s : total time 2 mins)
          </aside>

        </section>


        <section data-background="#007777" data-background-transition="slide">
        
          <h3>2. What might an API look like?</h3>
            <aside class="notes">
            The Chess Game is currently the only game implementation available so this example might be a little specific.
            But can you think of what this strategy function might look like?

            (time 30s : total time 2 mins 30 sec)
 
          </aside>
        </section>

        <section>

        <section data-markdown>
         <script type="text/template">
Strategy function Definition
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history]}]  ...)

=> {:move [:e2 :e4]})
```

Note:
Put yourselves in the place of a player. What would you need to make a decision. (pause)
The state of the board (move down) containing a vector of characters.
a list of valid-moves.
You might want to know the color of your team.
The History of all moves so you know exactly where you are in the execution of the game.
Finally (because it's chess), a flag to tell you when you re in-check. (pause)
As an aside, my initial cut of the API had all the information a strategy engine might want. Then I turned it into a map to make these parameters optional and extensible.
(For those familiar with the paradigm, it's data driven api.)

            (1 min : total time 3 mins 30 s)

         </script>
        </section>

        <section data-markdown>
         <script type="text/template">
A board
-----------------------
        
```clojure
[\r \n \b \q \k \b \n \r
 \p \p \p \p \p \p \p \p
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \P \P \P \P \P \P \P \P
 \R \N \B \Q \K \B \N \R]
```

Note:
a vector of characters
         </script>
        </section>

        <section data-markdown>
         <script type="text/template">
Move Coordinates
-----------------------
        
![d](img/board.png)

```clj
["e2" "e4"]  ; ["source" "destination"]
```

Note:
A move being a pair of source-destination according to the coordinates convention on this image.
         </script>
        </section>


        </section>


        <section data-markdown>
Avoiding recomputation
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]  ...)

=> {:move [:e2 :e4] :state 42})
```
Note:
The game engine can also hold a state for you to store arbitrary data structures. For example to store your expensive calculations which you can pass in the returned map with the option state keyword.

(30s : total time 4 mins)

        </section>


        <section data-markdown>
Possible implementation
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]
                      (let [v (into [] valid-moves)]
                        (let [move (rand-int (count valid-moves))]
                          {:move (get v move), :state nil})))
```
Note:
Here is an extremly simplified suggested implementation...
It's my helloworld example, it returns an arbitrary valid move.
The idea is to not write the whole of the chess engine alone. Other people submit 
their chess strategy implementation. The engine only ensures valid execution of the game.

The developer of this strategy will want to evaluate which move is the best, probably using a MinMax/beta pruning algorithm. For the moment the author of the function will have to implement all this scafolding themselves inside their function as only anonymous functions are allowed and no external functions are available at this point. But I'm considering providing documented helper functions like list-of-valid-move, apply-move-to-board and basic MinMax in future in order to lower the level of entry to the platform.

(1 min 30 : total time 6 min )

        </section>

        <section  data-background="#007777" data-background-transition="slide">
        
          <h3>3. How is the website designed?</h3>
            <aside class="notes">
            Lets now look at the design of the website.

(10s : total time 6 min 10)

          </aside>          
        </section>

        <section id="designObjectives"> 

          <h3>Website Design Objectives</h3>
 
            <ul>
              <li class="fragment">Submit a strategy function</li>
              <li class="fragment">Authentication</li>
              <li class="fragment">Strategy ranking</li>
              <li class="fragment">Replay</li>
              <li class="fragment">Human play</li>
              <li class="fragment">Turn Based Game Agnostic</li>
            </ul>

          <aside class="notes">
            When I designed this website I wanted to have:
            an area for a user to submit a strategy function;
            an authentication method to remember the platform user;
            stats to be publicly visible;
            replay area;
            human play area; 
            Finally pave the way for the implementation of other "turn based" games
            (1 min : total time 7 mins)
          </aside>

        </section>




        <section data-markdown>
Application Stack
-----------------

* Browser
 * ClojureScript
 * Clidget
* Common
 * Async
 * Chord/Websocket
* Web Server
 * Friends
 * Compojure/Ring/Hiccup
 * Clojail
 * clj-chess-engine
    * State Monad
    * Unfold
 * MondgoDB

Note:
With that in mind, that's why I needed some sandboxing mechanism, to execute the strategy function safely. The Clojail library is fullfilling this role. By the way Clojail is also used on the 4Clojure website.

As you can see the chess-engine (clj-chess-engine) is an independent library used by the webserver. This paves the way to pull in other "turn based" games. It is incidently also useful if you want to independently reuse the chess-engine to build another chess game else where which share the same semanatic. Chess-engine is just a pure chess api which can be used anywhere. (pause)
The authentication on the server is managed by the Friends library which I found easy enough to integrate. (pause)
To implement the play/replay functionality, a UI was needed. ClojureScript and Clidget provided an attractive way to implement a complex interactive UI. (pause)
Finally to wire the client and server together, Async/Chord libraries provided an elegant asynchronous mechanism to update the browser based widgets in real time.


(1 min : total time 8 min)

        </section>

        <section>

          <img BORDER="0" src="img/submit.png" alt="submit stack">
          <a href="http://lambda.zone">http://lambda.zone</a>
            <aside class="notes">
            This gives you an overview of the application. It's made of 3 components: WebServer running the Chess-Engine, browser running ClojureScript and the Database.
            There are various client server communication mechanisms like REST calls and WebSockets across the same page. (pause)
            On the top of the main web page is the authentication provided by the Friends library using the openId protocol. This means, you don't need to create yet another account. You can use any of the providers available to authenticate. (pause)
            Then the page contains two fields, one to give a unique name to your strategy and another to paste your function implementation.
            For the moment it must be an anonymous function. Any sub-function must be inlined in a let block. The code is submitted via a rest call. It will be executed against all the other functions, already present on the server, to generate some stats (displayed at the bottom of the page). (pause)
            The execution is made on the server and is sandboxed with Clojail. (p) This means, no thread creation, no def, no Java interops are allowed. Execution time of a user function is bounded so users cannot take the server down with an infinite loop. (p)
            Real time updates of the games execution and of the stats are send back asynchronously to the browser, providing an entertaining  animation every time a function is submitted. (p)
            The stats section, lists the ranking of the functions and list all the match's results.
            Clicking on a match result will take you to this replay page...

            (5 mins : total time 13 mins)

          </aside>        
        </section>
        <section>

          <img BORDER="0" src="img/replay.png" alt="replay stack">
          <aside class="notes">
            On the replay page, one rest call is used to retreive the list of moves of the game at the bottom of the page.  another rest call fetches the state of the board every time the prev or next button are pressed. the board is refreshed with Clidget which abstract the notion of graphic component in ClojureScript. It's true Ajax, there are no refresh of the page.

            (1 mins : total time 14 min)
          </aside>
        </section>

        <section data-background="#007777"  data-background-transition="slide">

          <h3>4. The Chess Engine Implementation</h3>
           <aside class="notes">
            Enough of the WebApplication. Let's dive into the Chess-engine implementation.

            (15s : total time 14 min 15)

          </aside>

        </section>
        <section id="designObjectives2"> 

          <h3>Chess Engine Design Objectives</h3>
 
            <ul>
              <li class="fragment">Purely functional</li>
              <li class="fragment">Independent</li>
              <li class="fragment">data driven</li>
              <li class="fragment">Easy to debug</li>
              <li class="fragment">Turn Based Game Agnostic</li>
            </ul>

          <aside class="notes">
            My design objectives were: to have a purely functional implementation to avoid multiple passes to figure out the impact of a chess move on a mutating game state. ;
            Independent so the engine is not coupled to any UI, any game strategy, free of any state or file mutation. The engine only execute the game from a pure data structure perspective. ;
            Data-driven so the engine calls me rather than me having to poke the state machine in the right order to change state.;
            must be easy to debug ;
            Reusable for other turn base games.

            (1 min : total time 15 mins)
          </aside>
        </section>
         <section data-markdown>

The Game is a state machine
-------------

```
init-board -(move1)-> board2 -(move2)-> ... board-n -(move-n)-> game-result
```

Note:
A game can be see as state machine where the board is the state and the move is the transition. (pause)
Does everybody intuitively agree with this? (pause)

         </section>
         <section data-markdown>

The Game is a language
-------------

```clojure
[move1 move2 ... move-n]
```

Note:
If you slice the state machine you can see the game is a parser that consumes a sequence of moves (move1, 2, 3 etc...) and produces a... (next page)

         </section>
         <section data-markdown>

The Game is a sequence of states
-------------

```clojure
[initial-board board2 ... board-n game-result]
```

Note:
... a sequence of game states followed by result as the final element.(pause)
How could we implement a game state machine in a purely functional way?

         </section>
         <section data-markdown>
Chess Engine building blocks
---------------

```clojure
(defn unfold [g seed]
  (->> (g seed)
       (iterate (comp g second))
       (take-while identity)
       (map first)))
```


```clojure
(fn g [state]         ; state <=> seed
  [value new-state])
```
Note:

We will answer the question but before let's take a quick detour.
To take a leaf from Haskell: 
Here is a possible implementation of the unfold function in Clojure.

who knows what unfold is?
Who knows what fold is?
What about reduce ?

Then you understand what unfold is if I tell you that unfold is the dual function of reduce.

Let me explain, Reduce uses...
(next)

(2 mins : total time 16 min)

        </section>

         <section data-markdown>
Reminder: what is reduce?
---------------

```clojure
(reduce f coll)
=> val
```


```clojure
(f state val)       ; state <=> acc
=> new-state
```
Note:

Reduce uses a function to agregate a collection into single value. (It happens to be called a Catamorphism in accademic circles.)
To acheive this, Reduce uses a function "f" of 2 arguments which returns a new state (often called accumulator).

(30 secs mins : total time 17 min)

        </section>
         <section data-markdown>
Catamorphism vs Anamorphism
---------------

```clojure
(reduce f coll)              |   (unfold g seed)
=> val                       |   => (val1 val2 ...)
```


```clojure
(f state val)                |   (g state)         ; state <=> seed
=> new-state                 |   => [val new-state]
```
Note:
Unfold does the oposite, it uses a function to expend a seed into a collection of values (a.k.a Anamorphism). 
To understand, the  "g" function (see here) used by unfold, takes a seed (let's view it as a state for now) and retuns a value and a new state. The values (not the state) ends up forming the collection which is returned by unfold. Unfold is a sort of sequence generator. A little bit like the iterate function, except that the unfold keeps the sequence of seeds and the sequence of values separated. (by the way, I have written a blog on this subject if anyone is interested in more details)

The "g" function happens to be a Monadic value of a State Monad. This is very convenient because State Monads can easily compose and manage state very elegantly. In a way I can unfold a monadic value (the step function of our game) and expended into a sequence of States.

The take away here is that I have found the use of the unfold function and State Monads to offer an elegant way to implement a purely functional state machine. It can also be viewed as a parser which starts with the initial board state and comsumes moves step by step to deliver an end game result. No atoms are used to achieve this.

(3 mins : total time 19 min)

Side comment: Monads return monadic values. For example a sequence monad in Clojure is just and array. 


        </section>
        <section>
         <section data-markdown>
          <script type="text/template">
An Engine which Unfolds
------------------------
        
```clojure
(defn game-seq [monadic-step init-state]
  (unfold
   monadic-step
   init-state
   ))

```


```clojure
(defn play-game-step [{:keys [board f1 f2 id1 id2 white-turn? move-history state-f1 state-f2 iteration channel game-id] :as game-context}]
   ...
   (check-mate? board white-turn? move-history)
   ....
   [value new-state])) ; returns
```

```clojure
(defn game-step-monad-wrap [game-step]
  (domonad state-m
           [res (fetch-val :result)
            a game-step
            s (fetch-state)
            :when (nil? res)]
           [a s] ))
```


Note:
Lets look briefly at some of code extracts from the Chess-Engine library to see how the unfold function is used to implement the chess game. 
Just to remind you, a game is a sequence of game states followed by result as the final element (show bottom slide briefly). The "game-seq" function returns this sequence as a lazy  (because of the unfold). Each step of the game are computed by the "g" function of the unfold which is this (play-game-step) function (the monadic value in itself). This function is in reality much longer and too ugly to display. it's the heart of the engine. Because it's monadic it can be composed and wrapped by this function (game-step-monad-wrap) to analyse the state and terminate the sequence under the appropriate condition. The composability also enables to break the step function into separate concerns. By the way this (domonad block) is a Monadic Comprehension. This is what is passed to the "game-seq" function.

It's all good what is the avantage of using all these clever monads instead of a good old loop?

Here this Chess-engine is very flexible. I could pass a slightly modified monadic-step to the game-seq to implement a complitely different engine. for example a replay rather than a play engine. All the sequencing logic remains the same. Only the step function changes. Also if I want to implement a different game like go or connect-foor, only the step function will have to be re-implemented. Additional the fact that it is purely functional opens up the possiblity of many games to be played safely in parallel.

  Troubleshooting and repeatability is another benefit. The game ends up being a long "immutable" sequence (at least as immutable as the strategy functions are...). This means I can take the state at any point of the sequence to test the step function in case I'm tracking a bug deep inside the engine.


(5 mins : total time 24 min)

         </script>
         </section>
         <section data-markdown>

Game sequence
-------------

```clojure
[state1 state2 ... state-n result]
```
Note:
Essentialy, a game is a sequence of game states followed by result as the final element.

         </section>
        </section>

        <section>
                  <img  border="0" src="img/Conclusion.jpg" alt="questions?">
            <ul>
              <li class="fragment">Reduced complexity</li>
              <li class="fragment">Same language across the server and the browser</li>
              <li class="fragment">Dynamic nature of Clojure</li>
              <li class="fragment">Clojail sandboxing => 3rd party code execution on server</li>
            </ul>
           <aside class="notes">
            The conclusion is that this application contains a lot of moving parts and uses a variety of technologies. (pause)
            Clojure gave me a few advantages to deliver a working solution:
            Reduced complexity, increased my productivity so much that I was actually able to get this website running in 5 months just working in the evenings and making sufficient consistant progress to keep my motivation up. I'm not convinced I would have been able to acheive the same in pure Java, in the same circumptances. (pause)
            I was able to use the same language across the server and the browser using consistent libraries with high level of abstraction.
            The Dynamic nature of Clojure and the availability of the Clojail sandbox provides a new way to design webapplications where 3rd parties can contribute in code.
            This unique mix made this application possible.

            

            (2 mins : total time 26 mins )

          </aside>
        </section>
        <section>
                  <img  width="420" height="400" border="0" src="img/question.png" alt="questions?">

                  <p>app: <a href="http://lambda.zone">http://lambda.zone</a>
                  <p>blog: <a href="http://www.matlux.net">http://www.matlux.net</a>
           <aside class="notes">
           I don't want to keep you away fromt he pub much longer.
           I think it's now time for questions.

            (4-19 mins : total time 30 - 45 mins )

          </aside>
        </section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
