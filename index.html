<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="Lambda Chess">
		<meta name="author" content="Mathieu Gauthron">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <section>
          <h1>lambda.zone</h1>
          <h3>A platform for competing algorithms</h3>

          <img  BORDER="0" src="img/LOWEMZONE.png" alt="lambda">
          <!--<img width="320" height="299" BORDER="0" src="img/lambda2.png" alt="chess">
          <img width="320" height="299" BORDER="0" src="img/chess2.png" alt="chess">  -->
          </p>
          Author:
          Mathieu Gauthron
          <aside class="notes">
            Today I'm going to present a webplatform that I have been working on for the past 5 months. It's called lambda.zone.

          </aside>
        </section>

        <section data-markdown>

What is it for?
-----------------

![d](img/board.png)

Note:
Its aim is to promote games like this one. Which I have called lambda chess.            

        </section>

        <section>
        
          <h3>And...</h3>

          <img width="320" height="299" BORDER="0" src="img/330px-Go-board-animated.gif" alt="go">
          <aside class="notes">
            or this one. which will be called lambda go.            
          </aside>

        </section>

        <section>
        
          <h3>and...</h3>

          <img width="320" height="299" BORDER="0" src="img/connect-four.jpg" alt="connect-four.jpg">
          <aside class="notes">
            or this one lambda connect-foor.          
          </aside>

        </section>

        <section>
        
          <h3>And many more...</h3>
          <h3>But what do they have in common?</h3>
            <aside class="notes">
            and so on.
            3 sec pause... 

            You might have noticed that they all are turn based adversarial games.
            This model is ideal to delegate the execution of an oponent throught the implementation of a strategy function.
          </aside>
        </section>

        <section>
        
          <h3>What might an API look like?</h3>
            <aside class="notes">
            
          </aside>
        </section>

        <section>

        <section data-markdown>
         <script type="text/template">
The function Definition
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history]}]  ...)

=> {:move [:e2 :e4]})
```

Note:
The board (move down) contains a vector of characters.
valid-moves contains a collection of moves.
Color is a boolean.
History contains a collection of moves.
A flag even tells you when you re in check.

         </script>
        </section>

        <section data-markdown>
         <script type="text/template">
A board
-----------------------
        
```clojure
[\r \n \b \q \k \b \n \r
 \p \p \p \p \p \p \p \p
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \P \P \P \P \P \P \P \P
 \R \N \B \Q \K \B \N \R]
```

Note:
a vector of characters
         </script>
        </section>

        <section data-markdown>
         <script type="text/template">
Move Coordinates
-----------------------
        
![d](img/board.png)

```clj
["e2" "e4"]  ; ["source" "destination"]
```

Note:
The board, valid-moves...
         </script>
        </section>


        </section>


        <section data-markdown>
Avoiding recomputation
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]  ...)

=> {:move [:e2 :e4] :state 42})
```
Note:
The game engine can also hold a state for you to store your expensive calculations
        </section>


        <section data-markdown>
Possible implementation
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]
                      (let [v (into [] valid-moves)]
                        (let [move (rand-int (count valid-moves))]
                          {:move (get v move), :state nil})))
```
Note:
Here is a suggested implementation...
The idea is I'm not writing the chess engine myself. Other people submit 
the chess strategy implementation.

        </section>

        <section>
        
          <h3>How is the website designed?</h3>
            <aside class="notes">
            How is this all designed?
          </aside>
        </section>

        <section data-markdown>
Application Stack
-----------------

* Browser
 * ClojureScript
 * Clidget
* Common
 * Async
 * Chord/Websocket
* Web Server
 * Friends
 * Compojure/Ring/Hiccup
 * Clojail
 * clj-chess-engine
    * State Monad
    * Unfold
 * MondgoDB

Note:
The website components are using the following libraries.

        </section>

        <section>

          <img BORDER="0" src="img/submit.png" alt="submit stack">
            <aside class="notes">
            This gives you anoverview of the application. It's made of 3 components: WebServer running the Chess-Engine, browser running ClojureScript and the Database.
            There are various client server communication mechanisms like REST calls in red and WebSockets in green.
            On the top of the main web page is the authentication done via the Friends library using openId. You don't need to create yet another account. You can use any of these providers to authenticate.
            Then the page contains two fields, to give a unique name to your strategy and another to paste your function implementation.
            For the moment it must be an anonymous function as described earlier. Any sub-function must be inlined in a let block. The code is submitted via a rest call. It will be executed against all the other functions to generate some stats (displayed at the bottom of the page).
            The execution is made on the server and is sandboxed with Clojail. No thread creation, no def, no Java interops are allowed. Execution time of a user function is bounded so users cannot take the server down with an infinite loop.
            Real time updates of the games execution and of the stats are send back asynchronously to the browser, providing an entertaining  animation every time a function is submitted.
            The stats section, lists the ranking of the functions and list all the match's results.
            Clicking on a match result will take you to this replay page...
          </aside>        
        </section>
        <section>

          <img BORDER="0" src="img/replay.png" alt="replay stack">
          <aside class="notes">
            2 rest calls retreive the list of moves of the game and the state of the board at each step of the game.
          </aside>
        </section>

        <section>

          <h3>The Chess Engine Implementation</h3>
           <aside class="notes">
            Enough of the WebApplication. Let's dive into the Chess-engine implementation.
          </aside>

        </section>

        <section data-markdown>
Chess Engine building blocks
---------------

```clojure
(defn unfold [g seed]
  (->> (g seed)
       (iterate (comp g second))
       (take-while identity)
       (map first)))
```


```clojure
(fn g [seed]
  [value new-seed])
```
Note:
To take a leaf from Haskell: who knows what unfold is?
Who knows what fold is?
What about reduce is?

Reduce uses a function to agregate a collection into single value. (It happens to be called a Catamorphism.)
Unfold does the oposite, it uses a function to expend a seed into a collection (a.k.a Anamorphism). A little bit like the iterate function except  that the unfold keep the sequence of seeds and the sequence of values separated.
To understand, the function "g" used by unfold takes a seed and retuns a value and a new seed. The values end up forming the collection which is returned by unfold.

The "g" function happens to be a Monadic value of a State Monad. This is very convenient because State Monad can easily compose and manage state very elegantly. I a way I can unfold my monadic value to be expended into a sequence of States.

Side comment: Monads return monadic values. For example a sequence monad in Clojure is just and array. 

The take away here is that I have found the use of the unfold function and State Monads to offer an elegant way to implement a purely functional state machine. It can also be viewed as a parser which starts with the initial board state and comsumes moves step by step to deliver an end game result. No atoms are used to achieve this.

        </section>


        <section data-markdown>
          <script type="text/template">
An Engine which Unfolds
------------------------
        
```clojure
(defn game-seq [monadic-step init-state]
  (unfold
   monadic-step
   init-state
   ))

```


```clojure
(defn play-game-step [{:keys [board f1 f2 id1 id2 white-turn? move-history state-f1 state-f2 iteration channel game-id] :as game-context}]
   ...
   (check-mate? board white-turn? move-history)
   ....
   ))
```

```clojure
(defn game-step-monad-wrap [game-step]
  (domonad state-m
           [res (fetch-val :result)
            a game-step
            s (fetch-state)
            :when (nil? res)]
           [a s] ))
```


Note:
Lets look briefly at some of code extracts from the Chess-Engine. 
Essentialy, a game is a sequence of game states and a result as a final element. "game-seq" returns the corresponding lazy-sequence by calling unfold. Each step of the game are computed by the "g" function of the unfold which is the this (play-game-step) function (the monadic value in itself). This function is much longer and too ugly to display. it's the heard of the engine. Because it's monadic it can be composed and wrapped by this function (game-step-monad-wrap) to analyse the state and terminate the sequence under the appropriate condition. By the way this (domonad block) is a Monadic Comprehension. This is what is passed to the "game-seq" function.

It's all good what is the avantage of using all these clever monads instead of a good old loop?

Here my Chess-engine is very flexible. I can pass a slightly modified monadis-step to my game-seq to implement a replay rather than a play engine. All the sequencing logic remains the same. Only the step function changes. Also if I want to implement a different game like go or connect-foor, only the step function will have to be re-implemented.


         </script>
        </section>


        <section>
                  <img  border="0" src="img/question.png" alt="questions?">
        </section>


        <section>
          <h2>Superb Tables</h2>
            <table>
              <thead>
                <tr>
                  <th>Item</th>
                  <th>Value</th>
                  <th>Quantity</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Apples</td>
                  <td>$1</td>
                  <td>7</td>
                <tr>
                <tr>
                  <td>Lemonade</td>
                  <td>$2</td>
                  <td>18</td>
                <tr>
                <tr>
                  <td>Bread</td>
                  <td>$3</td>
                  <td>2</td>
                <tr>
              </tbody>
            </table>
            <aside class="notes">
            Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
          </aside>


```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]
                      (let [v (into [] valid-moves)]
                        (let [move (rand-int (count valid-moves))]
                          {:move (get v move), :state nil})))
```

        </section>
        <section data-markdown>

Is this a good example of use of an Atom?
-----------------------------------------

```clojure
(def state-of-world  (atom 0))

(defn process-step []
  (swap! state-of-world inc))

(for [i (range 10)]
  (do (process-step)
      @state-of-world))
;;=> (1 2 3 4 5 6 7 8 9 10)
```
        </section>


        <section id="fragments">

          <h3>But first ...</h3>
 <p class="fragment"> A Quiz</p>
            <ol>
              <li class="fragment"><em>Who Think Atoms are the best way to manage state in Clojure?</em></li>
              <li class="fragment"><em>Are Monad for academics and not useful in Clojure?</em></li>
            </ol>
        </section>



			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
