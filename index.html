<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="Lambda Chess">
		<meta name="author" content="Mathieu Gauthron">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <section>
          <h1>lambda.zone</h1>
          <h3>A platform for competing algorithms</h3>

          <!--<img  BORDER="0" src="img/LOWEMZONE.png" alt="lambda">-->
          <img width="320" height="299" BORDER="0" src="img/lambda2.png" alt="chess">
          <!--<img width="320" height="299" BORDER="0" src="img/chess2.png" alt="chess">-->
          </p>
          Author:
          Mathieu Gauthron
          <aside class="notes">
            Today I'm going to present a webplatform written entirely in Clojure that I have been working on for the past 5 months. I have called it lambda.zone.

            (total time 20s)

          </aside>
        </section>

        <section data-markdown>

What is it for?
-----------------

![d](img/board.png)

Note:
Its aim is to promote games like this one. Which I have called lambda chess.            

(time 10s : total time 30s)
        </section>

        <section>
        
          <h3>And...</h3>

          <img width="320" height="299" BORDER="0" src="img/330px-Go-board-animated.gif" alt="go">
          <aside class="notes">
            or this one. Lambda go.            
            (time 10s : total time 40s)
          </aside>

        </section>

        <section>
        
          <h3>and...</h3>

          <img width="320" height="299" BORDER="0" src="img/connect-four.jpg" alt="connect-four.jpg">
          <aside class="notes">
            or lambda connect-four.          
            (time 10s : total time 50s)
           </aside>

        </section>

        <section>
        
          <h3>And many more...</h3>
          <h3>But what do they have in common?</h3>
            <aside class="notes">
            and so on.
            (3 sec pause)... 
            Has anyone notice what they have in common?
            Yes! I would say they all are turn based adversarial games.
            This model is ideal to delegate the decision of an oponent throught the implementation of a strategy function.
            (time 40s : total time 1 min 30)
          </aside>
        </section>

        <section>
        
          <h3>What might an API look like?</h3>
            <aside class="notes">
            I have only implemented the Chess Game at the moment so it might be a bit specific.
            But can you think of what would this strategy function look like?

            (time 30s : total time 2 mins)
 
          </aside>
        </section>

        <section>

        <section data-markdown>
         <script type="text/template">
Strategy function Definition
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history]}]  ...)

=> {:move [:e2 :e4]})
```

Note:
Put yourselves in the place of a player. What would you need to make a decision. (pause)
The state of the board (move down) containing a vector of characters.
a list of valid-moves.
The color of your team.
The History of all moves.
even flag to tell you when you re in-check.

            (1 min : total time 3 mins )

         </script>
        </section>

        <section data-markdown>
         <script type="text/template">
A board
-----------------------
        
```clojure
[\r \n \b \q \k \b \n \r
 \p \p \p \p \p \p \p \p
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \- \- \- \- \- \- \- \-
 \P \P \P \P \P \P \P \P
 \R \N \B \Q \K \B \N \R]
```

Note:
a vector of characters
         </script>
        </section>

        <section data-markdown>
         <script type="text/template">
Move Coordinates
-----------------------
        
![d](img/board.png)

```clj
["e2" "e4"]  ; ["source" "destination"]
```

Note:
The board, valid-moves...
         </script>
        </section>


        </section>


        <section data-markdown>
Avoiding recomputation
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]  ...)

=> {:move [:e2 :e4] :state 42})
```
Note:
The game engine can also hold a state for you to store arbitrary data structures. For example to store your expensive calculations

(30s : total time 3 min 30)

        </section>


        <section data-markdown>
Possible implementation
-----------------------
        
```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]
                      (let [v (into [] valid-moves)]
                        (let [move (rand-int (count valid-moves))]
                          {:move (get v move), :state nil})))
```
Note:
Here is a suggested implementation...
It's my helloworld example, it returns a valid move. But that's just a very simple example.
The idea is I'm not writing the whole of the chess engine myself. Other people submit 
their chess strategy implementation. My engine only ensures valid execution of the game.

(40s : total time 4 min 10)

        </section>

        <section>
        
          <h3>How is the website designed?</h3>
            <aside class="notes">
            Let's now look at the design.

(10s : total time 4 min 20)

          </aside>
        </section>

        <section data-markdown>
Application Stack
-----------------

* Browser
 * ClojureScript
 * Clidget
* Common
 * Async
 * Chord/Websocket
* Web Server
 * Friends
 * Compojure/Ring/Hiccup
 * Clojail
 * clj-chess-engine
    * State Monad
    * Unfold
 * MondgoDB

Note:
The website components are using the following libraries.

(describ browser common and server)
As you can see the chess-engine is an independent library. which is convenient if you either want to add another game or if you want to independently reuse the chess-engine to create another chess game. Chess-engine is just a pure chess api.

(1 min : total time 5 min 20)

        </section>

        <section>

          <img BORDER="0" src="img/submit.png" alt="submit stack">
            <aside class="notes">
            This gives you an overview of the application. It's made of 3 components: WebServer running the Chess-Engine, browser running ClojureScript and the Database.
            There are various client server communication mechanisms like REST calls in red and WebSockets in green across the same page.
            On the top of the main web page is the authentication provided by the Friends library using openId. This means, you don't need to create yet another account. You can use any of these providers to authenticate.
            Then the page contains two fields, one to give a unique name to your strategy and another to paste your function implementation.
            For the moment it must be an anonymous function as described earlier. Any sub-function must be inlined in a let block. The code is submitted via a rest call. It will be executed against all the other functions, already present on the server, to generate some stats (displayed at the bottom of the page).
            The execution is made on the server and is sandboxed with Clojail. This means, no thread creation, no def, no Java interops are allowed. Execution time of a user function is bounded so users cannot take the server down with an infinite loop.
            Real time updates of the games execution and of the stats are send back asynchronously to the browser, providing an entertaining  animation every time a function is submitted.
            The stats section, lists the ranking of the functions and list all the match's results.
            Clicking on a match result will take you to this replay page...

            (5 mins : total time 10 mins)

          </aside>        
        </section>
        <section>

          <img BORDER="0" src="img/replay.png" alt="replay stack">
          <aside class="notes">
            one rest call is used to retreive the list of moves of the game at the bottom of the page.  another rest call fetches the state of the board every time the prev or next button are pressed. the board is refreshed with Clidget which abstract the notion of graphic component in ClojureScript. It's true Ajax, there are no refresh of the page.

            (1 mins : total time 11 min)
          </aside>
        </section>

        <section>

          <h3>The Chess Engine Implementation</h3>
           <aside class="notes">
            Enough of the WebApplication. Let's dive into the Chess-engine implementation.

            (15s : total time 11 min 15)

          </aside>

        </section>

        <section data-markdown>
Chess Engine building blocks
---------------

```clojure
(defn unfold [g seed]
  (->> (g seed)
       (iterate (comp g second))
       (take-while identity)
       (map first)))
```


```clojure
(fn g [seed]
  [value new-seed])
```
Note:
To take a leaf from Haskell: who knows what unfold is?
Who knows what fold is?
What about reduce ?

Then you understand what unfold is if I tell you that unfold is the dual function of reduce.

Reduce uses a function to agregate a collection into single value. (It happens to be called a Catamorphism in accademic circles.)
Reduce uses a function of 2 arguments and return one.
Unfold does the oposite, it uses a function to expend a seed into a collection of values (a.k.a Anamorphism). A little bit like the iterate function, except that the unfold keeps the sequence of seeds and the sequence of values separated.
To understand, the  "g" function (see here) used by unfold, takes a seed and retuns a value and a new seed. The values (not the seeds) ends up forming the collection which is returned by unfold.

The "g" function happens to be a Monadic value of a State Monad. This is very convenient because State Monads can easily compose and manage state very elegantly. In a way I can unfold a monadic value (the step function of our game) and expended into a sequence of States.

Side comment: Monads return monadic values. For example a sequence monad in Clojure is just and array. 

The take away here is that I have found the use of the unfold function and State Monads to offer an elegant way to implement a purely functional state machine. It can also be viewed as a parser which starts with the initial board state and comsumes moves step by step to deliver an end game result. No atoms are used to achieve this.

(5 mins : total time 15 min)


        </section>

        <section>
         <section data-markdown>
          <script type="text/template">
An Engine which Unfolds
------------------------
        
```clojure
(defn game-seq [monadic-step init-state]
  (unfold
   monadic-step
   init-state
   ))

```


```clojure
(defn play-game-step [{:keys [board f1 f2 id1 id2 white-turn? move-history state-f1 state-f2 iteration channel game-id] :as game-context}]
   ...
   (check-mate? board white-turn? move-history)
   ....
   ))
```

```clojure
(defn game-step-monad-wrap [game-step]
  (domonad state-m
           [res (fetch-val :result)
            a game-step
            s (fetch-state)
            :when (nil? res)]
           [a s] ))
```


Note:
Lets look briefly at some of code extracts from the Chess-Engine to see how the unfold function is used to implement the chess game. 
Essentialy, a game is a sequence of game states and a result as a final element. "game-seq" returns that sequence. Each step of the game are computed by the "g" function of the unfold which is this (play-game-step) function (the monadic value in itself). This function is in reality much longer and too ugly to display. it's the heard of the engine. Because it's monadic it can be composed and wrapped by this function (game-step-monad-wrap) to analyse the state and terminate the sequence under the appropriate condition. The composability also enables to break the step function into separate concerns. By the way this (domonad block) is a Monadic Comprehension. This is what is passed to the "game-seq" function.

It's all good what is the avantage of using all these clever monads instead of a good old loop?

Here my Chess-engine is very flexible. I can pass a slightly modified monadic-step to my game-seq to implement a replay rather than a play engine. All the sequencing logic remains the same. Only the step function changes. Also if I want to implement a different game like go or connect-foor, only the step function will have to be re-implemented. Additional the fact that it is purely functional opens up the possiblity of many games to be played safely in parallel.

  Troubleshooting and repeatability is another benefit. My game ends up being a long sequence. This means I can take the state at any point of the sequence to test the step function in case I'm tracking a bug deep inside the engine.


(5 mins : total time 20 min)

         </script>
         </section>
         <section data-markdown>

Game sequence
-------------

```clojure
[state1 state2 ... state-n result]
```

         </section>
        </section>

        <section>
                  <img  border="0" src="img/Conclusion.jpg" alt="questions?">
           <aside class="notes">
            The conclusion is that this application contains a lot of moving parts and uses a variety of technologies.
            Clojure gave me a few advantages to deliver a working solution:
            Reduce complexity, increase my productivity so much that I was actually able to get this website running in 5 months just working in the evenings and making sufficient consistant progress to keep my motivation up. For example I would have lost the plot trying to acheive the same in Java in the same circumptances.
            I was able to use the same language across the server and the browser using consistent libraries with high level of abstraction.
            The Dynamic nature of Clojure and the availability of the Clojail sandbox provides a new way to design webapplications where 3rd parties can contribute in code.
            This unique mix made this application possible.

            

            (2 mins : total time 22 mins )

          </aside>
        </section>
        <section>
                  <img  border="0" src="img/question.png" alt="questions?">
           <aside class="notes">
            Any question?

            

            (10 mins : total time 32 - 45 mins )

          </aside>
        </section>


        <section>
          <h2>Superb Tables</h2>
            <table>
              <thead>
                <tr>
                  <th>Item</th>
                  <th>Value</th>
                  <th>Quantity</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Apples</td>
                  <td>$1</td>
                  <td>7</td>
                <tr>
                <tr>
                  <td>Lemonade</td>
                  <td>$2</td>
                  <td>18</td>
                <tr>
                <tr>
                  <td>Bread</td>
                  <td>$3</td>
                  <td>2</td>
                <tr>
              </tbody>
            </table>
            <aside class="notes">
            Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
          </aside>


```clojure
(fn [{:keys [board valid-moves am-i-white? in-check? history state]}]
                      (let [v (into [] valid-moves)]
                        (let [move (rand-int (count valid-moves))]
                          {:move (get v move), :state nil})))
```

        </section>
        <section data-markdown>

Is this a good example of use of an Atom?
-----------------------------------------

```clojure
(def state-of-world  (atom 0))

(defn process-step []
  (swap! state-of-world inc))

(for [i (range 10)]
  (do (process-step)
      @state-of-world))
;;=> (1 2 3 4 5 6 7 8 9 10)
```
        </section>


        <section id="fragments">

          <h3>But first ...</h3>
 <p class="fragment"> A Quiz</p>
            <ol>
              <li class="fragment"><em>Who Think Atoms are the best way to manage state in Clojure?</em></li>
              <li class="fragment"><em>Are Monad for academics and not useful in Clojure?</em></li>
            </ol>
        </section>



			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
